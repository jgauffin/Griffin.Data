Mappings
========

Mappings are used to describe how a table can be mapped to a class.

```csharp
internal class UserMapping : IEntityConfigurator<User>
{
    public void Configure(IClassMappingConfigurator<User> config)
    {
        // Required since the table name differs from the class name
        config.TableName("Users");

        // required since we use a auto incremented column as PK.
        config.Key(x => x.Id).AutoIncrement();

        // Optional, but added to show how. Read more later.
        config.Property(x => x.FirstName);
    }
}
```

Mappings are automatically picked up by the `MappingRegistry` as long as you point on an assembly.

```csharp
var registry = new MappingRegistry();
registry.Scan(typeof(UserMapping).Assembly);
```

The mapping registry is in charge of loading and caching mappings. It's typically declare in the `DbConfiguration`.

# Table names vs class names

Table names are optional in the mappings as long as the table name is a plural version of the class name.
If they aren't, you need to turn that off:

```csharp
mappingRegistry.PluralizeTableNames = false;
```

If table names do not adhere to that rule, you can specify the table name in each mapping:

```csharp
internal class UserMapping : IEntityConfigurator<User>
{
    public void Configure(IClassMappingConfigurator<User> config)
    {
        config.TableName("ProdUsers");

        // [.. rest of the mapping...]
    }
}
```

# Column names vs property names

This library assumes that a property has the same name as the column. If that's not the case, you need to explicitly tell what the column name is.

```csharp
internal class UserMapping : IEntityConfigurator<User>
{
    public void Configure(IClassMappingConfigurator<User> config)
    {
        config.Property(x => x.FirstName).Column("first_name");

        // [.. rest of the mapping...]
    }
}
```

# Keys

Keys are used to be able to identify a specific row. All tables MUST have primary keys. 

Primary keys are also used by the change tracker to be able to identify two copies of the same entity.

Keys are defined like this:

```csharp
internal class UserMapping : IEntityConfigurator<User>
{
    public void Configure(IClassMappingConfigurator<User> config)
    {
        config.Key(x => x.MyKey);

        // [.. rest of the mapping...]
    }
}
```

Keys that are generated by the database must have  `.AutoIncrement()` to tell the mapper that the column should not be included in the INSERT statement and that the value should be fetched once the INSERT statement completes.

# Properties

Properties are fields that are not keys or child entities.

```csharp
internal class UserMapping : IEntityConfigurator<User>
{
    public void Configure(IClassMappingConfigurator<User> config)
    {
        config.Property(x => x.FirstName);

        // [.. rest of the mapping...]
    }
}
```

## Conventional property mapping

Properties where the column name matches the property name and where the data types are the same do not need to be mapped. Instead, invoke `MapRemainingProperties()` in the bottom of your mapping.

```csharp
internal class UserMapping : IEntityConfigurator<User>
{
    public void Configure(IClassMappingConfigurator<User> config)
    {
        config.Key(x => x.MyKey).AutoIncrement();

        // [.. rest of the mapping...]

        config.MapRemainingProperties();
    }
}
```


# Relationships

* [Has many](HasMany.md)
* [Has one](HasOne.md)
